** Лекция 2. Абстракция «исполнитель» и модели вычислений
   :PROPERTIES:
   :CUSTOM_ID: лекция-2.-абстракция-исполнитель-и-модели-вычислений
   :END:

* В прошлой лекции
  :PROPERTIES:
  :CUSTOM_ID: в-прошлой-лекции
  :END:

/Что такое вычислительная система?/

- Система это больше, чем сумма компонентов.
- Программа во время выполнения --- система; исходный код --- не
  система.
- Основная проблема систем --- /сложность/.
- Системы можно разбить на части структурно или функционально.

--------------

- Боремся со сложностью с помощью:

  - /модульности/ (конструируем систему по частям);
  - /абстракции/ (забываем устройство модулей, описываем только
    поведение).

- Вычислительные системы могут быть разными.

- Часто встречаются три типа функциональных компонентов:

  - /исполнитель/ выполняет команды или реагирует на события;
  - /память/ хранит данные;
  - /транспорт/ соединяет части системы между собой.

--------------

* В этой лекции
  :PROPERTIES:
  :CUSTOM_ID: в-этой-лекции
  :END:

концентрируемся на абстракции /исполнитель/, узнаём понятие /модели
вычислений/ и их примеры.

- узнаем многое, практически применимое в других языках;
- while/if, вызов процедур, объекты и классы --- капля в океане способов
  организации вычислений;
- есть много специализированных инструментов;
- как устроена программа на ассемблере (GNU\Linux, nasm, AMD64);
- как легко сделать самые сложные части первой лабораторной с помощью
  конечных автоматов.

--------------

* Исполнитель
  :PROPERTIES:
  :CUSTOM_ID: исполнитель
  :END:

- функциональный компонент;
- совершает действия активно или реактивно.

--------------

** Как описать правила игры?
   :PROPERTIES:
   :CUSTOM_ID: как-описать-правила-игры
   :END:

- Попробуем тривиальный алгоритм: поход в булочную через дорогу.
- Мы все можем справиться с задачей (?)

--------------

- Каждый даст своё описание опираясь на «очевидные» базовые действия.
- Варианты:

  - «открыть дверь», «взять ключ»; «выйти из дома»;
  - детальное описание движений рук и ног;
  - какие сигналы посылаются мышцам через нервную систему...

--------------

## Две проблемы

- идеям необходим язык для их выражения, и

- нельзя бесконечно конкретизировать базовые действия

  - Что такое «взять ключ»?
  - Что такое «протянуть руку»?
  - Что такое «найти глазами ключ»?
  - Как отличить ключ от не-ключа? ...

Нужно задать базу из которой всё строится.

--------------

- Вычисления можно организовать по-разному.
- Как выразить идею организации вычислений?

--------------

* Модель вычислений
  :PROPERTIES:
  :CUSTOM_ID: модель-вычислений
  :END:

набор базовых операций и их условная стоимость.

Разные наборы операций удобны в разных контекстах:

- выразить решение на подходящем языке быстрее и легче;
- могут быть ограничения (некоторые алгоритмы невозможно выразить).

Ограничения несут пользу:

- удобство (меньше вероятность, что что-то пойдёт не так);
- проанализировав программу, можно получить более точную информацию о её
  поведении.

--------------

Каждый язык программирования имеет модель вычислений.

Обычно, сперва изучают языки типа Java, C++, Python, Pascal...

Их модели вычислений похожи:

- плоская, линейно-адресуемая память;
- последовательное выполнение программ;

Универсально, но часто есть более подходящие инструменты. Часто удобно:

- решить задачу в подходящей модели вычислений;
- перевести на язык, на котором нужно реализовать решение.

--------------

* Модель вычислений: Конечные автоматы
  :PROPERTIES:
  :CUSTOM_ID: модель-вычислений-конечные-автоматы
  :END:

Конечный автомат (Finite State Machine) это:

- Набор событий (/входные символы/).
- Набор реакций (/выходные символы/).
- Набор состояний, из них выбираем одно начальное, одно или более
  конечных.
- Правила вида: «если мы в состоянии /A/ и произошло событие /I/,
  демонстрировать реакцию /O/ и перейти в состояние /B/».

#+BEGIN_HTML
  <p align="center">
#+END_HTML

#+BEGIN_HTML
  </p>
#+END_HTML

--------------

- Реакцию можно не демонстрировать.
- В какое состояние придём, такой и «результат».

** Пример. Чётное количество единиц
   :PROPERTIES:
   :CUSTOM_ID: пример.-чётное-количество-единиц
   :END:

События --- считывание очередного символа из строчки.

#+BEGIN_HTML
  <p align="center">
#+END_HTML

#+BEGIN_HTML
  </p>
#+END_HTML

--------------

** Пример. Разбираем число со знаком
   :PROPERTIES:
   :CUSTOM_ID: пример.-разбираем-число-со-знаком
   :END:

#+BEGIN_HTML
  <p align="center">
#+END_HTML

#+BEGIN_HTML
  </p>
#+END_HTML

--------------

** Другие примеры
   :PROPERTIES:
   :CUSTOM_ID: другие-примеры
   :END:

- Управление роботами, машинами.

  - События = показания сенсоров
  - Реакции = действия.

- Сетевые протоколы.

  - События = приём пакетов разного типа
  - Реакции = ответы.

--------------

** Пример. Протокол TCP
   :PROPERTIES:
   :CUSTOM_ID: пример.-протокол-tcp
   :END:

#+BEGIN_HTML
  <p align="center">
#+END_HTML

#+BEGIN_HTML
  </p>
#+END_HTML

[[https://www.researchgate.net/figure/TCP-Finite-State-Machine_fig1_260186294][Источник]]

--------------

** Пример. Пять состояний процесса
   :PROPERTIES:
   :CUSTOM_ID: пример.-пять-состояний-процесса
   :END:

#+BEGIN_HTML
  <p align="center">
#+END_HTML

#+BEGIN_HTML
  </p>
#+END_HTML

--------------

** Непривычное
   :PROPERTIES:
   :CUSTOM_ID: непривычное
   :END:

- Состояние компьютера --- значения всех регистров и ячеек памяти.
- Состояние автомата --- «кружочек», одно из фиксированного набора.
- У автомата нет памяти, никакой.

Когда в алгоритме действия и условия глобальны, автоматы удобны для его
описания.

На автоматах легко продемонстрировать понятия /недетерминизма/,
/неопределённости/ и /полноты/.

--------------

** Что такое недетерминизм?
   :PROPERTIES:
   :CUSTOM_ID: что-такое-недетерминизм
   :END:

Поведение --- последовательность переходов по состояниям.

- Несколько возможных переходов по одинаковому событию.

  - Мы в состоянии /A/, что если на входе 3?

- Не одно поведение, а /множество равноправных/.

#+BEGIN_HTML
  <p align="center">
#+END_HTML

#+BEGIN_HTML
  </p>
#+END_HTML

/Связано с/: неопределённым порядком вычислений в C, слабой моделью
памяти.

--------------

** Недетерминизм в C
   :PROPERTIES:
   :CUSTOM_ID: недетерминизм-в-c
   :END:

#+BEGIN_SRC C
  int f() { print("f"); return 1; }
  int g() { print("g"); return 1; }

  ...
  f() + g();
#+END_SRC

#+BEGIN_HTML
  <p align="center">
#+END_HTML

#+BEGIN_HTML
  </p>
#+END_HTML

=f() + g();= - =1 + g();= - =1 + 1= - =2=

=f() + g();= - =f() + 1;= - =1 + 1= - =2=

--------------

** Что такое неопределённость?
   :PROPERTIES:
   :CUSTOM_ID: что-такое-неопределённость
   :END:

- Мы в состоянии /A/, что будет если на вход придёт 1?
- Нет поведения.

#+BEGIN_HTML
  <p align="center">
#+END_HTML

#+BEGIN_HTML
  </p>
#+END_HTML

При реализации системы в неописанных случаях поведение «как получится».

/Связано с/: неопределённым поведением в C; используется чтобы
компилятор вставлял меньше проверок.

--------------

** Что такое полнота?
   :PROPERTIES:
   :CUSTOM_ID: что-такое-полнота
   :END:

- Полный автомат = не может быть неопределённого поведения.
- Из каждого состояния для каждого возможного события есть переход.
- Неполный можно достроить до полного добавив состояние.

*** Неполный автомат
    :PROPERTIES:
    :CUSTOM_ID: неполный-автомат
    :END:

#+BEGIN_HTML
  <p align="center">
#+END_HTML

#+BEGIN_HTML
  </p>
#+END_HTML

*** Построим полный автомат
    :PROPERTIES:
    :CUSTOM_ID: построим-полный-автомат
    :END:

#+BEGIN_HTML
  <p align="center">
#+END_HTML

#+BEGIN_HTML
  </p>
#+END_HTML

--------------

** Model Checking
   :PROPERTIES:
   :CUSTOM_ID: model-checking
   :END:

- Проверка свойств моделей с помощью автоматизированных анализаторов.
- Сильнее тестирования (проверяет всю систему целиком, а не частные
  случаи).
- Можно сразу спроектировать систему как конечный автомат и проверить
  его свойства.
- А можно сделать модель обычной программы как системы переходов.

--------------

** Системы переходов (transition systems)
   :PROPERTIES:
   :CUSTOM_ID: системы-переходов-transition-systems
   :END:

- Иногда можно представить функционирование произвольной системы
  (программы) как переход от состояния к состоянию.
- Описывается похоже на конечный автомат (структура Крипке).
- Модель процесса через цепочку переходов.

#+BEGIN_SRC C
  for (int x = 0; x < 3; x++) { }
#+END_SRC

#+BEGIN_HTML
  <p align="center">
#+END_HTML

#+BEGIN_HTML
  </p>
#+END_HTML

--------------

#+BEGIN_SRC C
  bool b = true;
  uint8_t x = 0;          // диапазон значений x от 0 до 255
  while( true ) {
          if (b == true)  if (x < 2) b = false;
     else if (b == false) {
                                  b = true;
                                  if (x < 2) x += 1;
                                 }
     print(x); print(b);
  }
#+END_SRC

#+BEGIN_HTML
  <p align="center">
#+END_HTML

#+BEGIN_HTML
  </p>
#+END_HTML

--------------

** Model Checking
   :PROPERTIES:
   :CUSTOM_ID: model-checking-1
   :END:

- Часто проверяет формулы *Linear Temporal Logic* (логика с кванторами
  по времени):

  - утверждения про значения переменных. =x > 0=, =y == x + 4=,
    =y != 9 && y < 17= ...
  - =G(утверждение)= утверждение всегда выполняется;
  - =F(утверждение)= в будущем утверждение будет выполнено; «хотя бы в
    какой-то момент утверждение будет выполнено»
  - =x U y= «утверждение /x/ выполняется пока /y/ не станет выполняться
    (возможно, и дольше)»
  - ...

- Верификатор может привести конкретный контрпример.

--------------

*** NuSMV
    :PROPERTIES:
    :CUSTOM_ID: nusmv
    :END:

- Один из model checker'ов.
- Определяет язык для описания модели.
- Есть переменные, но вся программа кодируется как автомат.
- Каждое состояние это набор из возможных значений всех переменных.
- В такой системе 300 состояний:

#+BEGIN_EXAMPLE
  VAR
     x: 1 .. 100 ;   -- x принимает значения от 1 до 100
     y: 5 .. 7 ;
#+END_EXAMPLE

--------------

Демонстрация

--------------

** Зачем верифицировать?
   :PROPERTIES:
   :CUSTOM_ID: зачем-верифицировать
   :END:

- Анализ логики в процессорах и промышленных контроллерах.
- Проверка свойств протоколов:

  - Протокол когерентности кэшей в многоядерных процессорах.
  - Анализ протоколов обмена данными.

- Разработка и анализ алгоритмов, особенно распределённых:

  - консенсус для распределённых БД.
  - управления и синхронизации в облаках (Amazon Web Services).
  - DHT алгоритмы (торренты).

- Разработка программно-аппаратных систем высокой надёжности с
  гарантированными свойствами:

  - Самолёты, ракеты, марсоходы...
  - Электростанции, турбины, двигатели...
  - Медицина, системы жизнеобеспечения...

--------------

** Model Checking: ключевые слова
   :PROPERTIES:
   :CUSTOM_ID: model-checking-ключевые-слова
   :END:

- Темпоральные логики: CTL*, CLT, LTL, TLA+
- Двоичные решающие диаграммы: ROBDD
- Разные направления

  - Explicit model-checking
  - Symbolic model-checking (NuSMV такой)
  - Probabilistic model-checking
  - Model-finding

- Mu-calculus
- Теория моделей (математическая логика)

--------------

* Модель вычислений: RAM-машина
  :PROPERTIES:
  :CUSTOM_ID: модель-вычислений-ram-машина
  :END:

- Алгоритмическая сложность считается для этой модели.

  - Все курсы «Алгоритмы и структуры данных».

- Привычная линейно-адресуемая память.
- Отдельно:

  - входные данные (только последовательное чтение) ;
  - выходные данные (только последовательная запись).

- Программы не могут себя изменять.

--------------

В реальности, в отличие от модели:

- Доступ к памяти неодинаково быстрый: важны порядок, локальность,
  выравнивание ...
- В модели арифметика делается за O(1) (но в реальности бывает длинная
  арифметика).
- Процессор выполняет не одну программу.
- Одна и та же инструкция процессора выполняется за разное время.
- Некоторые страницы памяти могут быть вытеснены на storage.
- Некоторые программы генерируются во время выполнения (JIT-компиляция).
- ...

--------------

** Сложность и три абстракции
   :PROPERTIES:
   :CUSTOM_ID: сложность-и-три-абстракции
   :END:

- Алгоритмическая сложность (исполнитель)

Сколько операций нужно, чтобы посчитать?

- Сложность по памяти (память)

Сколько нужно выделить памяти, чтобы посчитать?

- Коммуникационная сложность (транспорт)

Когда есть обмен между двумя агентами, как много информации нужно
передать чтобы ответить на вопрос?

--------------

** Пример задачи на коммуникационную сложность
   :PROPERTIES:
   :CUSTOM_ID: пример-задачи-на-коммуникационную-сложность
   :END:

- У Алисы в памяти есть строка, и у Боба в памяти есть строка. Мы знаем,
  что они отличаются одним битом.
- Как за минимальное количество переданных бит информации определить
  позицию отличающегося бита?
- Протокол должен быть заранее определён: кто кому при каких условиях
  сколько посылает.

Можно решать детерминированно, можно вероятностно.

--------------

* Модель вычислений: архитектура Intel 64
  :PROPERTIES:
  :CUSTOM_ID: модель-вычислений-архитектура-intel-64
  :END:

- 64-разрядная архитектура Intel 64 == AMD 64.
- Регистры, память со стеком, прерывания.
- Последовательное выполнение.
- В дальнейшем рассмотрим параллельное выполнение программ и виртуальную
  память.

--------------

** Программа, которая корректно завершает свою работу
   :PROPERTIES:
   :CUSTOM_ID: программа-которая-корректно-завершает-свою-работу
   :END:

#+BEGIN_EXAMPLE
  global _start

  ; комментарий -----------------------

  section .text
  _start:   mov     rax, 60          ; 'exit' syscall number
            mov     rdi, 0           ; rdi = 0
            syscall                  ; exit(0)
#+END_EXAMPLE

--------------

** Hello, world
   :PROPERTIES:
   :CUSTOM_ID: hello-world
   :END:

#+BEGIN_EXAMPLE
  global _start

  section .data                     
  message: db  'hello, world!', 10

  section .text
  exit:
      mov     rax, 60          ; 'exit' syscall number
      xor     rdi, rdi
      syscall                       
      ; ret

  _start:                           
      mov     rax, 1           ; 'write' syscall number
      mov     rdi, 1           ; stdout
      mov     rsi, message     ; address
      mov     rdx, 14          ; length in bytes
      syscall
      call exit
#+END_EXAMPLE

--------------

** Вывод регистра
   :PROPERTIES:
   :CUSTOM_ID: вывод-регистра
   :END:

Допустим в числе одна 16-ричная цифра, выведем её. Функцию =exit= см.
ранее.

#+BEGIN_EXAMPLE
  section .data
  codes: db      '0123456789ABCDEF'

  section .text
  print_hex8:                     ;    rdi = цифра
    add rdi, codes
    mov rsi, rdi
    mov rax, 1
    mov rdi, 1
    mov rdx, 1
    syscall
    ret
#+END_EXAMPLE

--------------

** Вывод регистра
   :PROPERTIES:
   :CUSTOM_ID: вывод-регистра-1
   :END:

#+BEGIN_EXAMPLE
  print_hex64: mov rcx, 64
  .loop:       push rdi
               sub rcx, 4
               sar rdi, cl
               and rdi, 0xf
               push rcx
               call print_hex8
               pop rcx
               pop rdi
               test rcx, rcx
               jnz .loop
               ret

  _start:
    mov rdi, 1122334455667788h
    call print_hex64
    call exit
#+END_EXAMPLE

--------------

* Реализация автоматов
  :PROPERTIES:
  :CUSTOM_ID: реализация-автоматов
  :END:

- Если задачу удобно решить в терминах автоматов, делаем это.

- Механически закодируем на языке, который необходимо использовать.

  1. Для каждого состояния заведём метку.
  2. Каждая метка начинается с «узнай текущее событие».
  3. В зависимости от события, показать реакцию и совершить переход на
     другую метку.

- Закодируем один из наших автоматов на ассемблере.

--------------

** Разобрать число в начале строки
   :PROPERTIES:
   :CUSTOM_ID: разобрать-число-в-начале-строки
   :END:

- Дано: указатель на начало строки
- Написать функцию, алгоритм:

  - если в начале строки число /n/: =rax = n=;
    =rdx = длина n в символах=;
  - если в начале строки не число, =rdx = 0=.

#+BEGIN_HTML
  <p align="center">
#+END_HTML

#+BEGIN_HTML
  </p>
#+END_HTML

--------------

*** Шаг 1
    :PROPERTIES:
    :CUSTOM_ID: шаг-1
    :END:

Начальные значения для подсчёта числа и его длины.

#+BEGIN_EXAMPLE
  mov rcx, 0     ; len = 0
  mov rax, 0     ; acc = 0
#+END_EXAMPLE

=rdx= понадобится для умножений.

--------------

*** Шаг 2
    :PROPERTIES:
    :CUSTOM_ID: шаг-2
    :END:

#+BEGIN_EXAMPLE
  A:  mov r8b, [rdi]
      inc rdi
  B:  mov r8b, [rdi]
      inc rdi
  OK: mov r8b, [rdi]
      inc rdi
  NO: mov r8b, [rdi]
      inc rdi
#+END_EXAMPLE

- Реакции будут связаны с накоплением числа в =rax= и длины в =rcx=.
- Можно нарисовать на диаграмме, но громоздко.

#+BEGIN_HTML
  <p align="center">
#+END_HTML

#+BEGIN_HTML
  </p>
#+END_HTML

--------------

*** Шаг 3: для всех состояний...
    :PROPERTIES:
    :CUSTOM_ID: шаг-3-для-всех-состояний
    :END:

#+BEGIN_EXAMPLE
  A:  mov r8b, rdi
      inc rdi
      cmp r8b, '0'     ; r8b < '0' || r8b > '9' -> NO
      jb NO
      cmp r8b, '9' 
      ja NO
      sub r8b, '0'
      ...             ; acc = acc * 10 + r8b
      ...             ; len = len + 1
      jmp B           ; '0' <= r8b <= '9' -> B
#+END_EXAMPLE

#+BEGIN_HTML
  <p align="center">
#+END_HTML

#+BEGIN_HTML
  </p>
#+END_HTML

--------------

** Литература
   :PROPERTIES:
   :CUSTOM_ID: литература
   :END:

- Ещё про абстракцию исполнителя

  - «Principles of Computer System Design», глава 2, секция «2.1 The
    Three Fundamental Abstractions» стр. 53--59.

- Конечные автоматы

  - «Low-level programming», глава 7, секция 7.1 «Finite State
    Machines", стр. 101--108
  - «Low-level programming», глава 2 «Assembly language», стр. 17--38.

--------------

** Литература
   :PROPERTIES:
   :CUSTOM_ID: литература-1
   :END:

- Про Model Checking:

  - https://www.embedded.com/an-introduction-to-model-checking/
  - https://www.cs.colorado.edu/~bec/courses/csci5535-s09/slides/lecture02.6up.pdf
  - http://svn.clifford.at/handicraft/2017/tttm/README
  - [[https://www.youtube.com/watch?v=GIrOek9sGyQ][Basic NuSMV Video
    Tutorial]]

- Коммуникационная сложность
  [[https://www.mccme.ru/free-books/dubna/razborov.pdf][Введение]]
