#+INCLUDE: "common/org-header.org" 
#+TITLE: Лекция 3. Модульность и абстракция.
-----
# <
* Лекция 3. Модульность и абстракция.
  :PROPERTIES:
  :UNNUMBERED: notoc
  :END:
-----
# >
* Материалы 
  :PROPERTIES:
  :UNNUMBERED: notoc
  :END:

  - "Principles of Computer System Design: an Introduction":
    - Глава 1, секции "1.4 Computer systems are the same but different", "1.5 Coping with complexity II"
    - Глава 4, секции "4.1 Client/Service Organization", "4.2. Communication between client and service"
  - "Low-level programming": Главы 2,  3
  - Joel Spolsky, [[https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/]["The Law of Leaky Abstractions"]].
  - [[https://tldp.org/LDP/lki/lki-2.html][Процессы в Linux]] (The Linux Documentation project)
  - Intel® 64 and IA-32 Architectures Software Developer’s Manual. Volume 2B: Instruction Set Reference, N-Z (документация на инструкции =prefetch0/1/2=).
    -----
    # < 
* В прошлой лекции
  :PROPERTIES:
  :UNNUMBERED: notoc
  :END:

  - Абстракция "*исполнитель*"
  - Примеры *моделей вычислений*: 
    - конечные автоматы
    - системы переходов, Model Checking
    - RAM машина.
  - Основы ассемблера для Intel 64 / AMD64
  - Кодирование конечных автоматов на ассемблере

  -----

  # >
* Краткое содержание
  :PROPERTIES:
  :UNNUMBERED: notoc
  :END:

  
  #+BEGIN_COMMENT
  В этом разделе мы обсудим следующие вопросы:
  #+END_COMMENT
  
  - Почему компьютеры стали такими сложными?
  - Усложнее software и hardware
  - Модульность и абстракция в software и hardware
  - Соглашения вызова.
  - Как делать сложные системы более надёжными?
  - Как укрепить границы между модулями и зачем это нужно для многозадачности.
  - Протекание абстракций, или зачем Web-программистам ассемблер.

  # <
  Обещание: ваши программы будут реже превращаться в спагетти.
  # >
  
  #+BEGIN_COMMENT
  Почему компьютеры стали делать такими сложными? Как развитие компьютерных систем стало делом не просто одной корпорации, но многих и многих компаний, комитетов, исследовательских организаций?

  Создавать такие  системы тоже сложно. Пусть мы программируем, а не создаём аппаратуру сами, но даже /маленькие/ программы встраиваются в большую программно-аппаратную систему и начинают взаимодействовать с разными её частями. А в индустрии не редкость программы на миллионы инструкций. Так как же проектировать и развивать систему, состоящую из миллиардов движущихся частей?

  Если сложность системы с помощью различных трюков и смекалки не понижать, то достаточно скоро система становится неподъёмной для разработки и поддержки. Тогда её разработчики почти наверняка даже не смогут доделать её до конца. Какими путями можно снизить сложность?

  Один трюк мы уже увидели: в программировании это использование более подходящей для решения задачи модели вычислений. Например, если легко выразить систему как конечный автомат, сделайте это, а затем по надёжному, универсальному и простому алгоритму закодируйте систему на нужном языке. Тогда часть сложности уходит в трансляцию между моделями вычислений.
  
  Мы плотнее познакомимся с модульностью и абстракцией, увидим, как программа делится на части-модули на разных уровнях детализации, и устройство модулей скрывается от остальной системы. Если вы будете чаще думать про модульность ваших программ, вы чаще будете писать код с хорошей архитектурой. В ней сложность будет постоянно умело прятаться за абстракциями.

  Это настолько мощный подход к построению систем, что может сложиться впечатление, что абстракция скрывает от нас сложность модулей полностью, поэтому мы можем вечно жить в мире высоких уровней системы --- например, счастливо писать на высокоуровневых языках, ведь они нас отгородят от проблем внутри скрытых частей системы. На деле же абстракции почти всегда несовершенны и не скрывают сложность полностью, мы продемонстрируем несколько примеров. 

  Напоминаем, что в этом курсе мы не затрагиваем психологический, экономический аспекты истории развития компьютеров, которые, безусловно, важны для целостного понимания IT. Мы концентрируемся на столкновении растущей сложности систем с ограниченностью когнитивных ресурсов человека.

  #+END_COMMENT
  -----

  
* Почему компьютеры усложнялись?

  Компьютеры усложняются чтобы:

  - Решать задачи быстрее.
  - Решать больше задач.
  - Взаимодействовать со сложными устройствами.

    # <
    - Скачок от панели с лампочками до принтера.
    # >
    
    #+BEGIN_COMMENT
    
    Мы представили компьютер как систему из процессора, памяти и транспорта между ними. Затем к этому добавились хранилище, регистры, прерывания. Эту схему можно усложнять достаточно долго, но даже после добавления множества блоков процессора, кэшей, шин, контроллеров, она будет бесконечно проще, чем реальный компьютер, в котором один лишь процессор содержит миллиарды транзисторов.

    Почему компьютеры так сложны? Усложнение компьютеров позволяет им решать более сложные задачи. Во времена полётов на Луну от компьютера требовалось немногим более, чем решение математических уравнений, но вскоре компьютеры стали объединяться в масштабные сети, использоваться для обработки всё больших массивов данных, а также взаимодействовать с другими устройствами. Когда-то менять содержимое памяти можно было буквально руками, вставляя стержни в ячейки и таким образом устанавливая биты; однако этот подход налагает совершенно неразумные ограничения на сложность программ, которые можно таким образом закодировать. Если мы хотим просто распечатать результаты работы программы на бумаге, нам уже нужно контролировать не панель с лампочками, а устройство с движущейся бумагой и какой-то печатающей составляющей, например, матрицей. Это гораздо более сложное устройство, которым непросто управлять. Но кроме того оно ещё и медленное, поэтому компьютер может успеть сделать множество полезных вычислений пока принтер в сравнении с ЦПУ еле шевелится. Чтобы переключаться между управлением принтером и другими задачами, компьютер тоже нужно усложнять...
    
    Итак, компьютеры становятся всё сложнее, чтобы решать задачи быстрее, чтобы все их компоненты использовались по максимуму, чтобы решать больше разных типов задач и взаимодействовать с другими, всё более сложными устройствами.
    
    #+END_COMMENT

  -----  
* Hardware & software
  # <
  - Вычислительные системы = аппаратура + программы
  # > 
  #+BEGIN_COMMENT
  Когда-то никакие компьютеры не имели программной части. В первых компьютерах только сами схемы определяли, что за работа будет совершена. Инженеры быстро поняли, что менять такие системы и исправлять в них ошибки невероятно сложно, а ошибки появляются постоянно, поэтому стали делать их реконфигурируемыми. Софт стал той самой конфигурацией, которую можно менять. В фон Неймане и родственных архитектурах уже есть прошивка, софт, который управляет аппаратурой. Почти все современные компьютеры как вычислительные системы состоят из софта и аппаратуры.
  #+END_COMMENT

  # < 
  - Полезная работа компьютера рождается в  их взаимодействии, нельзя изучать их изолировано.
  # >

  # <
  - Главное отличие: софт не ограничен в сложности физическими законами.
  # >
  #+BEGIN_COMMENT
  Наличие изменяемой памяти не означает наличие софта. Память может выступать исключительно в роли хранилища данных, например, в компьютерах есть /кэш данных/, аппаратная реализация памяти, в которой инструкций не бывает. Существуют и такие компьютеры в которых вся логика поведения определяется схемами, а память выступает только как хранилище данных.

  Софт управляет компьютерной системой и является её функциональным компонентом. Стоит помнить, что сами по себе инструкции без исполняющей её аппаратуры ничего не значат. Задачи, возложенные на компьютеры, решаются в танце, где ведущим выступает софт, а его партнёром --- аппаратура.

  Усложнение компьютеров затрагивает и аппаратную, и программную часть.
  #+END_COMMENT
  
  -----
  
** Сложность hardware
   # <
   Проектировать компьютер слишком сложно. Разделяй и властвуй: 
   
   - Договориться об общей архитектуре.
   - Договориться об интерфейсах между модулями.

   Каждая компания развивает один модуль.

   - Все хотят делать "самые быстрые" комплектующие, это маркетинг.
   - Иногда можно ускорить, но слишком дорого.
     - Регистры быстрее, но дороже и занимают место на кристалле.

   - Физика: энергопотребление, паразитные токи на высоких частотах и др.
       
   Результат: некоторые части компьютера могут работать быстрее, но простаивают.

   # >
   #+BEGIN_COMMENT

   Начнём со сложности аппаратуры. Почему нельзя сделать быструю память и быстрый процессор, оставив архитектуру системы такой же?

   Оказалось, что даже сделать просто компьютер с архитектурой фон Неймана целиком очень сложно. Отметим, что в то время не было компьютерного инструментария для того, чтобы, например, проектировать на компьютерах новые процессоры. Компаниям пришлось договариваться о стандартизации архитектуры, её высокоуровневом описании, а также об описании интерфейсов всех модулей, из которых она состоит. Заметьте, что мы говорим не о внутреннем устройстве модулей, а об их интерфейсах: сами модули внутри очень уж сложные, а вот их интерфейсы описать возможно.
   
   Затем каждая компания стала на чём-то специализироваться, и они перестали думать о системах целиком. Возникла гонка, где каждый старался из соображений маркетинга сделать свою часть самой производительной и показать себя в более выгодном свете, нежели конкуренты. Капитализм!

   Нет смысла делать сверхбыстрый процессор, который большую часть времени ожидает данные из медленной памяти. Когда всю систему делает одна команда разработчиков, инженеры не стремятся достичь максимальной производительности отдельных компонентов если система не сможет этим воспользоваться. А когда каждый компонент стала делать отдельная команда, так и случилось: части компьютеров стали слишком сильно различаться в производительности.

   Как поступают системные инженеры в такой ситуации? Вспомним пример с каньоном и поездом, который по нему едет. Чтобы максимизировать использование железной дороги нам пришлось усложнить систему, добавив стрелки, дополнительный путь и какую-то систему контроля, которая не позволяет поездам столкнуться. Так и с компьютерами: их пришлось снова усложнять чтобы более эффективно использовать, например, очень эффективный процессор.

   #+END_COMMENT
   -----
   
   #+CAPTION: Поезд в каньоне
   [[./img/train.svg]]
   
   -----
   
*** Максимизация использования ресурсов
    # <
    Процессор не должен простаивать.

    В системах максимизируют использование  ресурсов.

    Усложнение: по возможности предоставлять ресурс разным частям системы.
    # >
  #+CAPTION: Архитектура фон Неймана с дополнениями
  [[./img/von-neumann-complete.svg]]


    #+BEGIN_COMMENT

   Процессор оказалось разогнать легче, чем память, поэтому чтобы использовать процессор более эффективно, без простоев, в систему добавили промежуточные уровни памяти:  регистры и несколько уровней кэшей. Помимо этого возникли и другие механизмы, мы упомянем три из них: предсказание ветвлений, предзагрузка данных в кэш и конвейер. Эти приёмы повышения производительности вы сможете найти и в программных системах, не только в аппаратуре.
    #+END_COMMENT

    -----
*** Предсказание ветвлений
    # <
    Угадываем ветки в переходах, если не угадали откатываемся.
    # >
     
    #+BEGIN_COMMENT
    Рассмотрим такой псевдокод:
    #+END_COMMENT
    #+BEGIN_SRC asm
      ; считаем rax = rbx + 3 * rcx
      mov rax, rbx
      add rax, rcx
      add rcx, rcx
      add rax, rcx
      ; if (rax < 5) goto yes
      cmp rax, 5
      jb yes
      ; первая ветка: rax < 5
      ...
      yes: ; вторая ветка: rax ≥  5
    #+END_SRC

    #+BEGIN_COMMENT
    Сначала программа считает значение регистра =rax= по формуле =rax = rbx + 3 * rcx=. Если =rax < 5=, то программа переходит с помощью инструкции =jb= на метку =yes=, иначе она продолжает выполнение. То есть, в зависимости от результата будет выполнена одна из двух веток кода.
    Пока процессор не подсчитал точное значение =rax=, он не знает, какая ветка будет выполнена. Но он может попробовать угадать ветку и начать выполнять её заранее. Если процессор угадал, то всё хорошо. Если не угадал --- придётся откатить все эффекты инструкций в неправильной ветке назад и начать выполнять правильную ветку.
    
    Процессор настолько быстрее всего остального, что даже если он не угадывает, это не очень замедляет вычисления. А угадывает он чаще, за счёт чего в среднем производительность повышается.

    Есть несколько распространённых стратегий для предсказаний веток: статические (не учитывающие то, как программа выполняется, и всегда предсказывающие одинаково) и динамические (с каким-то анализом истории выполнения программы). 
    #+END_COMMENT

    -----
    
*** Предзагрузка значений в кэш
    # <
    Угадываем, куда будут обращения в память, подгружаем в кэш.
    # >
    #+BEGIN_COMMENT
    Компьютеры умеют передавать данные из основной памяти в кэш не занимая вычислительный ресурс процессора. Если для программы в ближайшем будущем понадобятся данные с определённых адресов, имеет смысл заранее их закэшировать. Пока процессор что-то считает, можно инициировать процесс записи данных из памяти в кэш, а когда данные понадобятся, они будут уже в кэше.

    Иногда процессор может сам догадаться, что определённые данные ему скоро понадобятся. Например, если мы просматриваем длинный массив, процессор предполагает, что мы и дальше будем двигаться по массиву. При чтении из памяти длинных последовательностей данных процессор будет заранее подгружать данные в кэш.

    В случаях нетривиальных паттернов доступа к памяти процессор уже не сможет догадаться, что ему кэшировать. Существуют инструкции, подсказывающие процессору, что указанные данные имеет смысл закэшировать. Например, инструкции =prefetch0/1/2= в Intel® 64 and IA-32 Architectures Software Developer’s Manual. Volume 2B.
    #+END_COMMENT

    -----
*** Конвейер
     
    # <
    Команда выполняется по этапам на разных частях процессора

    Пока идёт второй этап команды, можно начать выполнять другую.

    Трюк можно использовать в распределённых системах, распределяя подзадачи на независимые ноды.

    # >
     
    #+BEGIN_COMMENT

    Процессор внутри состоит из множества блоков; инструкция при исполнении задействует некоторые из этих блоков. Причём на разных стадиях своего выполнения инструкции нужны разные блоки.

    Представим простейшую ситуацию: есть два блока процессора, каждая инструкция по очереди задействует эти блоки. Представим также две последовательные инструкции. Тогда пока первая инструкция не выполнится, вторая будет ждать доступа к первому блоку, хотя первой инструкции он может уже не быть нужен.
     
    Конвейеризация разделяет операцию на несколько подопераций и распределяет их по разным частям системы, чтобы они могли работать параллельно.

    Такой же трюк можно применять в распределённых программных системах. К примеру, в распределённой базе данных можно параллельно выполнять запросы, задействующие разные ноды в кластере.
    
    #+END_COMMENT
     
    -----

** Сложность software

   Программная часть систем гораздо сложнее, чем аппаратная.
   #+BEGIN_COMMENT
   Это может показаться абсурдным, ведь программы мы пишем постоянно.  А процессор сделать гораздо сложнее, чем написать небольшое приложение на Java. Однако даже простейший =Hello, world!= встраивается в огромную программно-аппаратную систему, включающую операционную систему, драйвера, другие запущенные приложения и т.д.

   Вот почему программная часть систем получается сложнее:
   #+END_COMMENT
   
   - Физические законы налагают меньше ограничений.
     
   #+BEGIN_COMMENT
   Если на создание аппаратуры налагают ограничения технологический процесс и фундаментальные физические законы (например, появление паразитных токов на высоких частотах), то сложность программ мы можем наращивать почти неограничено.
   #+END_COMMENT
   - Почти безграничные возможности композиции.

   #+BEGIN_COMMENT
     Не составляет труда быстро составить систему из нескольких огромных систем, например, связать Word и СУБД с помощью небольшого скрипта. Если получившаяся система неправильно работает, ошибка может быть в Word, в СУБД или в связке (макросах).
   
   Именно потому, что программы писать так сложно, а также потому, что мы в основном этим и занимаемся, оставшуюся часть мы посвятим тому, как бороться со сложностью программ с помощью модульности и абстракции.
   
   #+END_COMMENT

   -----

* Модульность и абстракция
  
  Чтобы проектировать архитектуру систем  нужно:

  - уметь разбивать систему на модули;
  - правильно их абстрагировать.

  #+BEGIN_COMMENT
В этом разделе мы поговорим про модульность и абстракцию именно в программах. Это знание пригодится вам вне зависимости от технологий и языков программирования, которые вы используете.
  #+END_COMMENT
  
  -----
** Программа как часть вычислительной системы

   #+BEGIN_COMMENT
   Напомним отношение между программами и вычислительными системами.
   #+END_COMMENT
   В любой системе /системные свойства/ --- результат взаимодействия частей системы.
   
   # <
   - Выполняющаяся программа --- система, включающая аппаратуру.
   - Исходный код программы не система: он неживой.
   # >

   #+BEGIN_COMMENT
   Исходный код программы после трансляции в машинные инструкции и запуска приложения "встраивается" в вычислительную систему.

   Когда программа написана в одном большом файле, она добавляет в вычислительную систему один большой модуль, который сложно изучать и отлаживать. Если же разделить исходный код на части, то запуск программы можно мысленно воспринимать как внесение в систему нескольких модулей поменьше.

   Одна из важных причин разделения системы на модули в том, что если сделать это удачно, то локализовывать ошибки с точностью до модуля становится достаточно просто. Если модуль при этом небольшой, то легче детально его изучить чтобы найти конкретное место в программе, которое нужно исправить.
   
   #+END_COMMENT
   -----

** Модульность: compile time & run time

   #+BEGIN_COMMENT
   Хотя исходный код программы не является системой, но в нём тоже можно выделить модули, которые потом проникнут в систему. Разбивка кода на модули разной степени гранулярности в каком-то виде сохраняется при компиляции и запуске программы.

   Важно понимать: хотя и работающая программа (система) и исходный код состоят из модулей, программа и исходный код это разные сущности. Поэтому и разбиения эти разные, и модули разные. Процессор, части операционной системы, драйвера, внешние устройства являются частями вычислительной системы, но не имеют отношения к исходному коду программы. Появятся при запуске и чисто софтовые модули, например, экземпляры процедур (об этом позднее).
   
   #+END_COMMENT

   # <
   - Система (программа) состоит из модулей.
   - Исходный код тоже состоит из модулей.
   - ... это две структурные декомпозиции, но разбиваются разные сущности и модули разные.

   # >
   
   #+BEGIN_COMMENT
   После разбиения на файлы можно и нужно разбивать программу на ещё более мелкие сущности. В зависимости от языка, это могут быть классы, функции, методы, пространства имён и многое другое. С точки зрения систем это будут тоже модули, только более низкого уровня.
   #+END_COMMENT


   # < 
   Два аспекта программ: compile time и run time.
   # >
   
   #+BEGIN_COMMENT
   Таким образом проявляются два аспекта многих из дисциплин, связанных с программированием:

   1. /Compile time/: как программы проектируются.
   2. /Run time/: как программы выполняются.

   
   #+END_COMMENT
   -----

** Абстракция: compile time & run time

   #+BEGIN_COMMENT
   Если модульность существует и в compile time, и в run time, верно ли, что абстрагировать можно не только модули системы, но и модули в исходном коде? Ответ --- да, и для статических, compile-time модулей, мы можем описывать их поведение абстрагируясь от внутреннего устройства и ненужных деталей.

   Многие языки программирования предоставляют инструменты для абстракции таких модулей. Например, интерфейс функций, как модулей системы --- набор аргументов и возвращаемое значение. Во многих случаях этой информации достаточно, чтобы пользоваться функцией, ничего не зная про её внутреннее устройство. Классы в Java имеют публичные и приватные поля и методы; при этом публичные поля и методы образуют интерфейс для экземпляра класса, а о приватных знать пользователю не только не нужно, но и, практически, запрещено языком.
   #+END_COMMENT

   # < 
   - Модули бывают сложными.
   - Поведение модуля важнее устройства (устройство объясняет поведение).
   - Поведение часто легче описать, чем устройство.

   /Абстракция/ --- вместо описания внутренностей модуля описываем его /интерфейс/ и поведение; внутренности скрываем.

   /Интерфейс/ --- способ взаимодействия с модулем.
   
   *Абстрагировать можно и модули в исходном коде*.

   # > 
   ----- 

* Модульность и абстракция в compile time

  #+BEGIN_COMMENT

  Для начала рассмотрим структуру кода на ассемблере, как одном из наиболее безыскусных языков. Для каждого уровня декомпозиции мы укажем средства абстрагирования модулей, если они существуют.
  
  #+END_COMMENT
  
** Структура кода программ
  
   Напомним  /структурную декомпозицию/ исходного кода на ассемблере:
 
   - Исходный код программы (проект)
     - Файл
       - Секция
         - функции
       - Секция
         - переменные
     - Файл
       - Секция

         ...

   -----

*** Файл

    #+BEGIN_COMMENT

    Вообще файл с исходным кодом программы это всего лишь именованный набор данных, то есть структурная единица хранения данных. Однако в ассемблерных файлах и в языке С на файл оказалась возложена и другая функция: он стал структурной единицей для самой программы.

    В общем случае файл не обязательно является структурной единицей для программы:

    - в Java связь между файлом-хранилищем кода и файлом-модулем системы ослаблена: структурной единицей программы является описание класса, но наложено условие, что в каждом файле может быть не более одного класса, помеченного =public=.
    - в C# файлы вообще никак не связаны со структурой программы; разве что нельзя дробить тело метода на несколько файлов (но определение класса --- можно).
    
    Язык Smalltalk обходится без файлов вообще --- там программа описывается как слепок состояния виртуальной машины, а структурной единицей программы является описание класса.

    Если файл --- это модуль, то чтобы реализовать абстракцию у него должен быть интерфейс, видимый другим файлам, и скрытая, абстрагированная часть.
    
    Точками взаимодействия с файлом являются метки. Обычные метки не видны извне файла, а метки для внешнего использования отдельно помечаются директивой =global=.
    
    #+END_COMMENT

    # <
    - Все метки описывают возможные точки взаимодействия.
    - Помеченные ~global~ метки описывают интерфейс.
    - ~extern~ подключается к интерфейсам других модулей. 
    # >

    -----
 
    #+BEGIN_SRC asm
; Переменная, доступная другим файлам
global x
section .data 
    x: db "Hello!"
    #+END_SRC

    #+BEGIN_COMMENT
    На другой стороне чтобы подсоединиться к коду из внешнего файла используется директива =extern=.
    #+END_COMMENT

    #+BEGIN_SRC asm
; Использование переменной из другого файла
extern x

section .text
  mov rax, x
    #+END_SRC


    #+BEGIN_COMMENT
    Таким образом, директивы =global= и =extern= --- средства абстракции файлов-модулей. Директива =global= служит для описания интерфейса к файлу; абстракция заключается в том, что все остальные метки в файле скрыты от внешнего мира.
    #+END_COMMENT
      
    -----


*** Cекции

    #+BEGIN_COMMENT
    В файле находятся секции, которые никак не отражаются в структуре программы, кроме как собиранием в отдельные кучки всех глобальных данных (в =.data=), отдельно неизменяемых данных (в =.rodata=), всего кода (в =.text=) и т.д.
    #+END_COMMENT
    
    # <
    Структурированно хранят данные или код.

    - Метки описывают интерфейс (где начинаются переменные или функции).
    - ... но можно обратиться к любому адресу внутри секции.
      
    # >


    #+BEGIN_COMMENT
    Внутри секции можно обращаться к любым адресам; в этом плане метки лишь выделяют некоторые адреса как "интересные" для программиста, потому что именно с этих адресов начинаются данные, функции, или на эти адреса нужно переходить.
    #+END_COMMENT
    -----
   

*** Функции, подпрограммы

    # <
    - Функции --- структурная единица кода.
# >
    #+BEGIN_COMMENT
    Функции также являются структурными единицами кода на языках высокого уровня. Мы привыкли думать о функциях как о минимальной единице построения кода.

    Функции упрощают код: их можно вызвать с аргументами, они возвращают значение и применяют побочные эффекты, такие, как ввод-вывод из файлов. Это показывает, что, во-первых, функции это модули, во-вторых, они абстрагируют свою реализацию за простым интерфейсом. Интерфейс функции это её вызов с аргументами, и получение возвращаемого значения.

    
    
    #+END_COMMENT
    
   #+begin_export latex
    \svgsetup{inkscapelatex=false}
    #+end_export

    #+CAPTION: Интерфейс функции как модуля.
  [[./img/function.svg]]
  
   #+begin_export latex
    \svgsetup{inkscapelatex=true}
   #+end_export
 # < 
    - На уровне ассемблера становятся /подпрограммами/.
    - Границы подпрограмм чётко не определены.
    - При вызове подпрограмм нет контроля аргументов.
    # >
    -----
  #+BEGIN_COMMENT 
   Чем меньше у функции сайд-эффектов, тем проще её подменять, анализировать, писать, тестировать. Поэтому в своих программах на любом языке сводите сайд-эффекты к минимуму. Это означает отказ от глобальных переменных и разделение логики и ввода-вывода: если функция что-то считает, она не должна выводить это, а должна передать как результат другой функции, которая уже и будет заниматься вводом-выводом. Старайтесь по возможности придерживаться правила: функция принимает всё, что ей нужно для работы, через аргументы, и все результаты работы возвращает через возвращаемое значение.
   
    На уровне ассемблера функции часто называют /подпрограммами/. Мы будем использовать этот термин когда необходимо подчеркнуть различия функций в языках высокого уровня и на уровне ассемблера.

    Отличия функций и подпрограмм: 

    1. Границы функций определены их телами: в Java, например, тело метода ограничено фигурными скобками.
    
          #+BEGIN_SRC java
          public static void main(String[] args)
          { // начало функции

          } // конец функции
          #+END_SRC

          Границы подпрограмм могут быть чётко не определены. Например, подпрограмма может иметь несколько точек входа, то есть можно начинать её исполнять с начала, а можно с середины. Где в таком случае провести её границы?
          Например, в этой программе мы можем вызвать функцию =print_hello= с середины, где стоит метка =print_string=; в таком случае можно передать в качестве аргумента произвольную строку для вывода.

          #+INCLUDE: "coroutine.asm" src asm
    #+END_COMMENT
    # < 
     Границы подпрограмм чётко не определены.
    #+INCLUDE: "coroutine.asm" src asm :lines "4-23"
    # >
    #+BEGIN_COMMENT
    2.  Подпрограммы оперируют в глобальном контексте.
         У функций есть локальные переменные и аргументы, которые являются изолированной частью состояния программы.
         
         Подпрограммы же оперируют с регистрами, а изменения регистров видны всем другим функциям. Неизолированность подпрограмм друг от друга нельзя полностью обойти, но часто чтобы зарезервировать кусочек памяти для локальных данных подпрограммы используют стек. Чуть далее узнаем, как это происходит.
    #+END_COMMENT
    -----
    #+BEGIN_COMMENT
    3. За вызовом подпрограмм нет никакого контроля. Если функция в Java принимает три аргумента, а вы передаёте ей два, код  с неправильным вызовом функции не скомпилируется. А подпрограммы можно запустить в любом контексте, вне зависимости от того, положили ли вы в регистры нужные аргументы и правильных ли они типов.

   
    #+END_COMMENT
    # <
    При вызове подпрограмм нет контроля аргументов.
    
    # >
    #+BEGIN_SRC  c 
      int sum(int a, int b) {
        return a + b;
      }
      ...
      rcx <- sum( 42 ) // ошибка: не хватает аргумента
    #+END_SRC

    #+BEGIN_SRC asm
        ; rdi = a, rsi = b
        sum: 
              mov rax, rdi
              add rax, rsi
              ret
      
        ...
        mov rdi, 42   
        call sum         ; Второй аргумент всё равно возьмётся из rsi
        mov rcx, rax     ; Скорее всего там мусорное значение
    #+END_SRC
   
    #+BEGIN_COMMENT
    Из-за того, что контроля за вызовом подпрограмм нет, приходится договариваться о том, как делать это единообразно. Невозможно устроить взаимодействие между разными функциями без согласования порядка аргументов, набора регистров, в которых они передаются, механизма передачи возвращаемого значения. Как мы увидим далее, эти /соглашения вызова/ играют важную роль в построении вычислительных систем.
   
   Теперь перейдём к выполнению программы и проследим, как части исходного кода программы разной степени гранулярности становятся модулями в вычислительной системе.
   #+END_COMMENT
   -----
     
* Модульность и абстракция в run time

  #+BEGIN_COMMENT

  Формат файла, структурирующий код, зависит от операционной системы. В Linux самым распространённым является формат ELF, о котором мы в деталях поговорим позже. ELF-файлы содержат метаданные, такие, как разметку на секции, названия меток и т.д.

  #+END_COMMENT
 
  # <
  После трансляции в машинные команды файл переводится в структурированный вид и может быть загружен в память /загрузчиком/.
  # >

  #+BEGIN_COMMENT

  Структура работающей программы во многом повторяет структуру исходного кода программы на ассемблере. Это одна из причин, по которой нам интересно изучение ассемблера.
  
  #+END_COMMENT
  -----

** Структура работающей программы

   #+BEGIN_COMMENT
   Сразу оговоримся, что мы для конкретики рассматриваем то, устроена работающая программа, запущенная под Linux или с использованием похожей ОС и архитектуры Intel. В большинстве распространённых контекстов всё сказанное останется верным, детали могут различаться. Однако если вы напишете свою ОС или сделаете платформу для запуска приложений, структура работающей программы у вас может быть совершенно непохожей.
  
   На высоких уровнях иерархии организация вычислительной системы зависит от приложения, которое выполняет пользователь. Мы начнём рассматривать структуру программы начиная с процессов.
   #+END_COMMENT
   
   - *Процесс* (контейнер для потоков и ресурсов: дескрипторы файлов...)

     # <
     Получен изо всего исходного кода и библиотек.
     # >

   #+BEGIN_COMMENT
   Каждый процесс содержит ресурсы, необходимые для функционирования программы: виртуальная память, дескрипторы открытых файлов, обработчики сигналов, информация про /рабочую директорию/, из которой был запущен процесс, и т.д.

   В образе процесса можно найти не только продукт трансляции исходного кода программы, но и библиотеки, в том числе динамические.
   #+END_COMMENT
   
   - Новая сущность: *поток* (выполнения инструкций, может быть несколько).

   #+BEGIN_COMMENT
   В языках, основанных на фон Неймановской модели вычислений или её наследниках, мы не описываем потоки явно.  При написании программы у нас есть иллюзия того, что она выполняется последовательно, в один поток. В реальности некоторые системные вызовы служат для создания новых потоков и запускают их параллельно.

   При выполнении программы процесс служит контейнером для потоков. Потоки также выступают единицей планирования, т.е. планировщик процессов на самом деле предоставляет процессор потокам, а не процессам.

   #+END_COMMENT

   - *Регионы* адресного пространства (контейнеры для секций).
     # <
     ~.text~ и ~.data~ загружаются в разные места памяти.
     # >

-----
   # <
  #+CAPTION: Загрузка файла в память
  [[./img/loading.svg]]
  # >
   
-----
   #+BEGIN_COMMENT
   У каждого процесса есть своё адресное пространство, оно общее для его потоков. При компиляции и компоновке программы все машинные инструкции собираются вместе и формируют одну большую секцию кода, то же самое происходит и с глобальными данными. При загрузке программы в память эти секции попадают в разные части виртуальной памяти.

   По отношению к секциям можно говорить о модульности, но не об абстракции. Можно обращаться ко всему, что загружено в память. Есть механизмы защиты от, например, перезаписи кода, которые предоставляются виртуальной памятью, но это не скрывает устройство секций кода или данных от других секций.
   
  #+CAPTION: Загрузка файла в память
  [[./img/loading.svg]]
  
   На самом низком уровне мы строим программу из подпрограмм. В работающем процессе к ним применимы все те же соображения, что и к подпрограммам в ассемблерном коде: они являются модулями, их интерфейс --- вызов и возврат из них.

   
   #+END_COMMENT
    

   - *Экземпляры функций* (запущенные функции и их локальные данные).

   # <
   Стек позволяет запустить несколько экземпляров функции с независимыми данными.
   # >
   
   #+BEGIN_COMMENT
   Во время выполнения добавляется ещё один тип сущности, которого нет в исходном коде: это экземпляры функций. При запуске функции она некоторое время живёт в программе, и в это время ей нужна память под её /локальные переменные/. А что если функция уже запущена, но нам нужно запустить её ещё раз с другими аргументами? Это не должно затронуть работу уже запущенной функции.

   Чтобы изолировать локальные переменные запущенных одновременно функций используют стек. Каждый раз, когда мы запускаем подпрограмму, в стек помещается её адрес возврата, а затем можно разместить её локальные переменные.
   
   Иллюстрация показывает результат выполнения инструкции =call f=, которую можно представить как пару действий: =push rip= и =jmp f=.
   
   #+END_COMMENT

  -----


   # <
   Адрес возврата в стеке.
   # >
   #+begin_export latex
    \svgsetup{inkscapelatex=false}
   #+end_export
   #+CAPTION: Адрес возврата в стеке.
   [[./img/ret-addr.svg]] 
   
   #+begin_export latex
    \svgsetup{inkscapelatex=true}
   #+end_export

   #+BEGIN_COMMENT

   Затем мы выделяем 24 байта под локальные переменные, отодвигая  =rsp=  к младшим адресам с помощью =sub rsp, 24=:

   #+END_COMMENT
   -----

   # <
   Локальные переменные в стеке.
   # >
   
   #+begin_export latex
    \svgsetup{inkscapelatex=false}
   #+end_export
   #+CAPTION: Локальные переменные в стеке.
   [[./img/locals.svg]]

   #+begin_export latex
    \svgsetup{inkscapelatex=true}
   #+end_export

   #+BEGIN_COMMENT
 
   Использование стека для организации вызовов функций и хранения локальных переменных позволяет:

   - запускать функцию многократно (например, =f= запускает =g=, которая запускает =f= снова);
   - устраивать рекурсию;
   - запускать функцию в нескольких потоках одновременно.

   #+END_COMMENT
   -----

   
* Соглашения вызова

** Системный взгляд
   #+BEGIN_COMMENT
   Функции --- это модули, интерфейс которых должен предоставлять две возможности:
   #+END_COMMENT
   # <
   - Функции --- это модули.
   - Интерфейс функций:
     # >
     - вызов из произвольного места кода;
     - возврат значения в место вызова.

   #+BEGIN_COMMENT
   На уровне ассемблера есть инструкции =call= и  =ret= для запуска подпрограммы и возврата из неё.
   Однако нет никаких инструкций, которые реализуют интерфейс передачи аргументов и возврата значения. 

   Как в этом случае передавать аргументы? Кажется, что выбор механизма передачи аргументов ложится на программиста.

   Когда весь код в компьютере находится под нашим контролем, например, если мы пишем свою операционную систему, мы можем придумать сами, в каких регистрах передавать аргументы, в каких возвращать значения, и использовать ли для этого вообще регистры, или стек.


   #+END_COMMENT

   -----

   # <
   В ассемблере есть только: =call=, =ret=, поддержки аргументов нет.

   Остальное придумываем сами?
   # >


  #+BEGIN_SRC asm
      int sum(int a, int b) {
        return a + b;
      }
    
      ...
    
      rcx <- sum( 42, 44 )
  #+END_SRC

  -----

  ... транслируется в код:

  #+BEGIN_SRC asm
      ; rdi = a, rsi = b
      sum: 
            mov rax, rdi
            add rax, rsi
            ret
    
      ...
      mov rdi, 42
      mov rsi, 44
      call sum
      mov rcx, rax
  #+END_SRC

  -----

** Соглашение вызова

   # <
   Договариваемся о /соглашениях вызова/:
   - чтобы все функции вызывать одинаково;
   - чтобы переиспользовать код.
   # >
   
   #+BEGIN_COMMENT
   Чтобы иметь возможность, с одной стороны, переиспользовать код, написанный
   другими программистами, а с другой --- не запутаться в том, какие функции
   вызывать каким образом, программисты выработали соглашения вызова. Это конвенции,
   описывающие, как передавать аргументы и как возвращать значения из функций.
   #+END_COMMENT

   На x64 два распространённых соглашения:

   1. System V AMD64 ABI (Linux, FreeBSD, MacOS)

      Полностью описывается в документе "System V Application Binary Interface".

   2. Microsoft x64 (Windows, UEFI)

   # <
   Отличий немного, пока мы сконцентрируемся на упрощённой версии System V.
   # >

   #+BEGIN_COMMENT
   В педагогических целях мы сконцентрируемся только на одном из соглашений --- System V. Постепенно мы детализируем его.
   #+END_COMMENT

   -----
    
**  System V AMD64 ABI (первое приближение)

   #+BEGIN_COMMENT
   Мы используем соглашение вызова, которое описывает интерфейс вызова подпрограмм следующим образом:

   1. Первые шесть аргументов передаются через регистры:

        =rdi=  =rsi= =rdx=
        =rcx= =r8= =r9=

         Достаточно запомнить первые три регистра.
       
   2. Остальные аргументы передаются через стек в обратном порядке.

       Например, при вызове функции =f(a,b,c,d,e,x,y,z)= на вершине стека будет лежать =z=, а сразу за ним --- =y=.
       Если бы все аргументы передавались через стек, вызовы подпрограмм были бы более медленными.

   3. Возвращаемое значение передаётся через регистр =rax=; можно вернуть второе значение через регистр =rdx=.

   #+END_COMMENT
   # <
   - Первые шесть аргументов :: (запомните три):
     =rdi=  =rsi= =rdx=
     =rcx= =r8= =r9=

   - Остальные аргументы  :: через стек в обратном порядке.
     Регистры быстрее, чем стек.
   - Возвращаемое значение :: в =rax=, дополнительное в =rdx=.

   # >

   -----

** Системные вызовы
   
   На AMD64 соглашения для системных вызовов и для подпрограмм разные.
   
   #+BEGIN_COMMENT
   Аргументы системных вызовов передаются через другие регистры: четвертый аргумент передаётся не в =rcx=, а в =r10=. Это связано с тем, что =syscall= использует =rcx= чтобы сохранить значение =rip= и передать его в обработчик системных вызовов.
   #+END_COMMENT

   - Аргументы передаются в регистрах:
     - =rdi= =rsi= =rdx=
     - =r10= вместо =rcx= (=syscall= использует =rcx= )
     - =r8= =r9=
   # <
   - *Ограничение на 6 аргументов*.
     # >
     
   #+BEGIN_COMMENT
   Заметим, что в разных ОС системные вызовы могут реализовываться через разные инструкции, которые ведут к передаче управлению ОС, а не только =syscall=.
   #+END_COMMENT

   -----


** Второе приближение

#+BEGIN_COMMENT
   Рассмотрим следующий пример:
#+END_COMMENT

   #+BEGIN_SRC asm
       ; rdi = адрес строки
       string_length:
           xor rax, rax
           .counter: cmp byte [rdi+rax], 0
                          je .end
                          inc rax
                          jmp .counter
                .end:  ret
       ; rdi = адрес строки
       print_string:
           call string_length
           mov rdx, rax
           mov rax, 1
           mov rsi, rdi
           mov rdi, 1
           syscall           ; вызов write
           ret
   #+END_SRC

   Есть ли здесь ошибка?
   
   -----
   Пусть наши коллеги переписали =string_length=.
    
   #+BEGIN_SRC asm
       ; rdi = адрес строки
       string_length:
           mov rax, rdi
           .counter:
               cmp byte [rdi], 0
               je .end
               inc rdi
               jmp .counter
           .end:
           sub rdi, rax
           mov rax, rdi
           ret
       ; rdi = адрес строки
       print_string:
           call string_length
           mov rdx, rax
           mov rax, 1
           mov rsi, rdi
           mov rdi, 1
           syscall           ; вызов write
           ret
   #+END_SRC 

   #+BEGIN_COMMENT
   Проблема оказалась в том, что в новой реализации =string_length= стал использовать регистр =rdi=, чего раньше не происходило. Теперь при вызове =string_length= регистр =rdi= затирается её служебным значением, поэтому для функции =print_string= вызов =string_length= убирает адрес начала строки из регистра =rdi=.

   Эта проблема свидетельствует несовершенстве соглашения вызова: никто не запрещал разработчику =string_length= использовать регистр =rdi=. Суть удобства функций как модулей в том, чтобы их можно было разрабатывать изолированно и не думать об остальной системе.
   #+END_COMMENT
   -----

   # <
   #+BEGIN_SRC asm
       string_length:                   ; old
         xor rax, rax
         .counter:
             cmp byte [rdi+rax], 0
             je .end
             inc rax
             jmp .counter
         .end:
             ret
       string_length:                  ; new
           mov rax, rdi
           .counter:
               cmp byte [rdi], 0
               je .end
               inc rdi                      ; !!!!
               jmp .counter
           .end:
           sub rdi, rax
           mov rax, rdi
           ret
     
   #+END_SRC

   Поменяли реализацию функции и программа перестала работать.

   Поменяли реализацию модуля и система перестала работать.

   # >
     
   -----
     
   # <
   Регистры нужно сохранять (но какие?)
   # >
     
   #+BEGIN_COMMENT
   TODO redundant
   
   Сравним состояние программы внутри функции =print_string= перед вызовом =string_length= и после него.
     
   - До вызова в регистре  =rdi= находился адрес начала строки.
   - После вызова в =rdi= может находиться что угодно, а в =rax= лежит длина строки.
     
   Нам неважно, что хранится в других регистрах, поэтому пусть =string_length= их и перезапишет, на работу =print_string= это не повлияет.
     
   Таким образом, чтобы исправить баг в программе достаточно сохранить =rdi= в стек перед вызовом, а затем восстановить:
   #+END_COMMENT
     
   #+BEGIN_SRC asm
       ; rdi = адрес строки
       string_length:
       ...
       ; rdi = адрес строки
       print_string:
           push rdi        ; !
           call string_length
           pop rdi         ; !
           mov rdx, rax
           mov rax, 1
           mov rsi, rdi    ; <---- здесь требуется: rdi = адрес строки!
           mov rdi, 1
           syscall         ; вызов write
           ret
   #+END_SRC 

   -----

** Callee- и caller-saved регистры
   #+BEGIN_COMMENT

   То, какие регистры нужно сберечь во время вызова, зависит от двух факторов:

   - В каких регистрах хранятся ценные данные, важные для дальнейшего функционирования программы?
   - Какие регистры могут измениться при вызове функции?


   Относительно второго фактора существуют два полярных подхода:

   - можно разрешить подпрограммам изменять любые регистры; тогда при вызове подпрограммы любые регистры могут измениться.
   - можно запретить подпрограммам изменять любые регистры; тогда функции будут обязаны восстанавливать содержимое всех регистров, которые они использовали.


      
   #+END_COMMENT

   # <
   Делим регистры на две категории: callee-saved и caller-saved.

   # >
   #+BEGIN_COMMENT
   Оба подхода приведут к понижению производительности, потому что придётся сохранять слишком много регистров.
   Кроме того, регистры, которые используются для передачи аргументов в подпрограммы, нет смысла восстанавливать.
   Поэтому обычно в соглашениях используется гибридный подход с разделением регистров на две категории: callee-saved и caller-saved.

   #+END_COMMENT

*** Callee-saved

    #+BEGIN_COMMENT
    Одни регистры (называемые /callee-saved/) нужно беречь. Они могут быть использованы, но при выходе из подпрограммы их значение должно быть таким же, как и при запуске подпрограммы.
    #+END_COMMENT

    Эти регистры бережёт /callee/ (тот, кого вызывают):

    - =rbp= и =rsp=, участвуют в механизме вызова функций;
    - =rbx= , нужен в динамических библиотеках;
    - =r12=, =r13=, ... =r15=, для удобства.

    -----
*** Caller-saved 
    #+BEGIN_COMMENT
    Другие регистры (называемые /caller-saved/) можно менять как угодно. При вызове подпрограмм нужно сохранять те из них, данные в которых важны для дальнейшего функционирования программы, как =rdi= в примере.
    #+END_COMMENT
    Эти регистры бережёт  /caller/ (тот, кто вызывает). Это почти все регистры.

   Вы можете свободно использовать их в своих подпрограммах. 

    -----
    #+BEGIN_COMMENT
    Резюмируя, более полное описание соглашения вызова должно отвечать на вопросы:
    #+END_COMMENT
    # <
    Соглашение вызова:
    # >
    - Как передавать аргументы (регистры, стек...)
    - Как возвращать значения (регистры, стек...)
    - Какие регистры точно не изменятся после вызова (callee-saved).
    - Какие регистры могут измениться после вызова (caller-saved).

    # <
    Зависит от процессора, операционной системы, среды исполнения (в случае языков для виртуальных машин).
     
    # >
    #+BEGIN_COMMENT
    Как мы увидели в примере со =string_length=, невыполнение соглашения вызова может не вести к тому, что программа аварийно завершит работу. Это может стать бомбой замедленного действия, которая сработает когда вы измените одну из функций, и вскроется ошибка в другой функции, вызывающей её.
    #+END_COMMENT

-----

* Абстракция и соглашения вызова

  #+BEGIN_COMMENT
  Функции это модули в системе, которой является работающая программа. Их можно вызывать, передавая им аргументы, и получать от них значения.

  Всё, что связано с работой функции, но не является возвращаемым значением, называют /побочными эффектами/ функции. Обычно к побочным эффектам относят:

  - работу с файлами;
  - работу с сетью;
  - запись в глобальные переменные;
  - запись в память через указатели;
  - ввод-вывод и др.
  
  #+END_COMMENT

  #+CAPTION: Интерфейс функции как модуля в системе.
  [[./img/function.svg]]
  
  # <
  - Разные реализации модулей, соответствующие одному интерфейсу, должны быть неотличимы.
  - Соглашения вызова помогают обеспечить взаимозаменяемость функций с одинаковым интерфейсом.
    # >

  #+BEGIN_COMMENT
TODO redundant

  Остальные свойства функций скрыты, то есть абстрагированы: мы не должны знать, как именно функции подсчитывают свои значения.

  Функции, которые считают одно и то же, обладают одинаковыми побочными эффектами и возвращаемым значением должны быть взаимозаменяемыми. В системе вообще необходимо, чтобы модуль можно было подменить на другой, с таким же интерфейсом, прозрачно для остальных частей системы.

  Соблюдение соглашения вызова необходимо, чтобы детали выполнения функции были скрыты от остальной программы (других частей системы), которая её вызывает. Скрытие деталей, в свою очередь, позволяет легко переписывать функции и подменять их реализации.
  
  #+END_COMMENT
  -----

* Протекание абстракций

  #+BEGIN_COMMENT
  Абстракции помогают нам следующим образом:

  - Описывая модули через их поведение, а не структуру, упрощают их использование.
  - Скрывая часть описания модуля, облегчают изменение и подмену модулей, т.к. скрытые части модуля точно напрямую не взаимодействуют с внешним миром.

  В идеальном мире абстракция полностью скрывает от нас внутреннее устройство модуля и даёт ему более простое описание. В реальном мире это скорее редкость, и как правило поведение реального модуля не полностью укладывается в упрощённое, высокоуровневое описание.
  #+END_COMMENT

  # <
  Взаимодействие по сети выглядит будто запись в файл (но сеть может не доставить данные).
  # >
  #+BEGIN_COMMENT

  Рассмотрим ситуацию, когда мы посылаем по сети TCP-пакет. Протокол TCP /гарантирует/ доставку пакета, в отличие от, например, протокола UDP. Оба они действует поверх протокола IP, то есть TCP-пакеты упакованы внутрь IP-пакетов. Протокол IP не гарантирует доставку пакетов: потеря пакета считается нормальной ситуацией.

  Протокол TCP же будет пытаться отправить потерянный пакет снова и снова, и для отправки пакета будет использовать ненадёжный протокол IP.

  Однако никакое количество попыток пересылки пакета не приведут к его доставке если получатель выключил компьютер или перерезал сетевой кабель. В этом случае абстракция со свойствами гарантированной доставки, которую предоставляет TCP, не скрывает нас от деталей нижележащих слоёв системы, в которых пакеты не могут быть доставлены с гарантией.


  #+END_COMMENT

  Говорят, что абстракция /протекает/, если она не полностью скрывает внутреннюю структуру модуля.
    
  #+BEGIN_COMMENT

  Другой пример связан с криптографией. Можно изучать время выполнения тех или иных действий модулем и таким образом получить информацию о его внутреннем устройстве, например, о том, на каких входных данных он работает медленнее. Это опасно с точки зрения безопасности, так как взломщики криптографических алгоритмов иногда могут таким образом открывать достаточно информации о ключах шифрования, чтобы их эффективно подбирать.
   
  Многие ошибки в системах обусловлены тем, что разработчики слишком полагались на высокоуровневое описание системы и не думали о более низких уровнях.
  
  Между тем часто случается, что удобные системы с гарантиями строятся поверх так называемых /best-effort систем/, как протокол TCP поверх IP. В best-effort системах происходит попытка удовлетворить запрос пользователя, но неуспех операций это штатная ситуация. Так же происходят чтения и записи из памяти и хранилища на самом низком уровне, коммуникация между компьютером и внешними устройствами и т.д. В программных системах встречаются ситуации, когда в силу несовершенства программы она иногда аварийно завершается; в этом случае в качестве временного решения используют принцип "запускать пока программа не доработает до конца". Временное решение, к несчастью, почти всегда становится постоянным.

  Поэтому даже если мы пользуемся высокоуровневыми абстракциями и инструментами, такими, как языки высокого уровня, нам всё равно нужно знать, что происходит под капотом на несколько уровней системы вниз.  Абстракции действительно упрощают нашу жизнь и позволяют нам писать программы более эффективно, но практически каждая из них в тех или иных условиях протечёт, и если вы не знаете, что она абстрагирует,
  #+END_COMMENT

  Абстракции экономят время на создание систем, но обучаться дольше.

  #+BEGIN_COMMENT
  Поэтому с каждым годом стать хорошим программистом всё тяжелее, потому что учиться приходится всё большему количеству технологий.

  Стоит отметить также, что /хорошие абстракции протекают меньше/. Старайтесь, чтобы в ваших собственных программах абстракции были хорошими.
  #+END_COMMENT

  -----

** Последствия несоблюдения соглашений
  
   #+BEGIN_COMMENT
   Как мы говорили, функции абстрагируют часть логики с помощью интерфейса вызова с аргументами.

   [[./img/function.svg]]

   Эффект функции на состояние системы это возвращаемое значение и побочные эффекты; удобнее, когда эффектов нет или минимальное количество.
   Подпрограммы следуют этой схеме, однако при несоблюдении соглашения вызова подпрограмма может испортить состояние вызывающей её функции. Это происходит когда функция не восстанавливает caller-saved регистры (например, =rsp=), или когда вызывающая функция не сохраняет нужные регистры перед вызовом (см.  пример  c вызовом =string_length=).
   #+END_COMMENT

   # <
   [[./img/function.svg]]
   - Функция абстрагирует полезную работу с помощью интерфейса вызова с аргументами.


   - Вызов подпрограммы выглядит как вызов функции 
   ... но может портить состояние вызывающей функции.

   # >
   -----
    

   - Типичный сценарий:
     - В месте вызова ничего не ломается.
     - Ломается другая часть программы.
   - Типичный сценарий:
     - В месте вызова ничего не ломается.
     - Переписываем другой модуль.
     - Теперь ломается другая часть программы.

     #+BEGIN_COMMENT
     Если воспринимать подпрограммы или функции как модули, то несоблюдение соглашений вызова ведёт к ошибкам, распространяющимся по системе от модуля к модулю. В системах это один из наиболее тяжёлых для диагностики типов ошибок.
     В высокоуровневых многопоточных приложениях в индустрии такие ошибки порой ищутся *месяцами*.,
     #+END_COMMENT
     -----
     

* Анонс: Weak & Enforced modularity

  #+BEGIN_COMMENT
  Как мы увидели,  набор модулей-подпрограмм это очень хрупкая конструкция. Ошибки могут свободно распространяться между модулями; лёгкий способ этого достичь это не следовать соглашению вызова.
  #+END_COMMENT
  
  Модули-подпрограммы это пример /слабой модульности/ (weak modularity), не мешающей распространяться ошибкам по системе.
  
  /Сильная модульность/ (enforced modularity) ставит барьеры на пути распространения ошибок.

  Усилить модульность в системе можно с помощью /клиент-сервисной архитектуры/ и/или /виртуализации/.

  -----

   #+BEGIN_COMMENT
   Пока мы рассматривали ситуацию с запуском одного приложения. Однако в реальности мы хотим, чтобы на компьютере одновременно выполнялось множество программ! Поскольку память в компьютере одна, оказывается, что из-за слабой модульности ошибки могут не только распространяться между процедурами, но и между приложениями. Любая программа может внести ошибку в работу любой другой --- это очень ненадёжная система.

   #+END_COMMENT
   
   # < 
   - Если процессы делят общую память и процессор, то могут свободно обмениваться данными и повреждать друг друга.
   # >
   
   [[./img/von-neumann-complete.svg]]

   # <
   - Процессы можно считать модулями в вычислительной системе.
   - Ошибка в модуле ведёт к падению всей системы --- *это слабая модульность*.
   #  >
   
   #+BEGIN_COMMENT
   На более примитивных системах типичной была ситуация, когда все процессы
   жили в одном адресном пространстве, без виртуальной памяти.
   #+END_COMMENT
   
   -----
# <
   - Модульность можно усиливать с помощью /клиент-сервисной архитектуры/ и /виртуализации/. 
   - В следующей лекции --- как /виртуализировать/ процессор и память.
     # >

   #+BEGIN_COMMENT
  Существуют два важных архитектурных приёма, укрепляющих границы между модулями в системе. Это клиент-сервисная архитектура и виртуализация функциональных компонентов.

  В следующем разделе мы поговорим про виртуализацию процессора и памяти, позволяющую изолировать процессы друг от друга.
  
   #+END_COMMENT


   

     [[./img/multiple-threads.svg]]


